package database

import (
	"time"

	"github.com/jinzhu/gorm"
)

// BaseModel is
type BaseModel struct {
	ID        string     `json:"id" gorm:"primary_key"`
	CreatedAt time.Time  `json:"-"`
	UpdatedAt time.Time  `json:"-"`
	DeletedAt *time.Time `json:"-" sql:"index"`
}

// ITransaction is
type ITransaction interface {
	GetDB(withTransaction bool) interface{} // this is for get the database with two mode with transaction or without transaction
	CommitTransaction(tx interface{})       // commit the transaction
	RollbackTransaction(tx interface{})     // rollback transaction
	RollbackOnException(tx interface{})     // for emergency rollback
}

// GormDB is
type GormDB struct {
	DB *gorm.DB
}

// NewGormDB is
func NewGormDB(db *gorm.DB) *GormDB {
	return &GormDB{db}
}

// GetDB is
func (g *GormDB) GetDB(withTransaction bool) interface{} {
	if withTransaction {
		return g.DB.Begin()
	}
	return g.DB
}

// CommitTransaction is
func (g *GormDB) CommitTransaction(tx interface{}) {
	tx.(*gorm.DB).Commit()
}

// RollbackTransaction is
func (g *GormDB) RollbackTransaction(tx interface{}) {
	tx.(*gorm.DB).Rollback()
}

// RollbackOnException is common handler for rollback the transaction
// to avoid database lock when something goes wrong in transaction state
// use with defer right after we call GetDB(true)
func (g *GormDB) RollbackOnException(tx interface{}) {
	// catch the error
	if err := recover(); err != nil {

		// rollback it!
		tx.(*gorm.DB).Rollback()

		// repanic so we can get where it happen in log!
		panic(err)
	}
}
